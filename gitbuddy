#!/usr/bin/env python3

import subprocess
import os
import sys

# Define color variables
RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
BLUE = '\033[34m'
MAGENTA = '\033[35m'
CYAN = '\033[36m'
RESET = '\033[0m'

# Function to run shell commands and return output
def run_command(command, capture_output=False):
    try:
        result = subprocess.run(command, shell=True, text=True, capture_output=capture_output, check=True)
        return result.stdout.strip() if capture_output else None
    except subprocess.CalledProcessError as e:
        if "git rev-parse" in command:  # Allow failure for this specific command
            return None  # Indicate the command failed without exiting
        print(f"{RED}‚ùå Error: {e}{RESET}")
        sys.exit(1)

# Clear screen (cross-platform)
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

# Check if we are inside a Git repository
def is_git_repository():
    result = run_command("git rev-parse --is-inside-work-tree", capture_output=True)
    return result is not None

# Function to get a multi-line commit message
def get_multiline_commit_message():
    print("Please enter your commit message. Use Shift + Enter for a new line. Press Enter twice to finish.\n")
    print(f"{MAGENTA}üí° Commit:{RESET}\n")
    lines = []
    while True:
        try:
            line = input()
            if line == "":
                break  # Stop input when user presses enter on an empty line
            lines.append(line)
        except EOFError:
            break
    return "\n".join(lines)


# Main script
def main():
    clear_screen()
    print(f"{BLUE}üöÄ Welcome to the Git Buddy!{RESET}\n")
    
    # Check if we're in a Git repository
    if not is_git_repository():
        print(f"{RED}‚ùå No Git repository found in the current directory.{RESET}\n")
        yn = input("Do you want to initialize a new Git repository? (y/n): ").strip().lower()
        if yn in ['y', 'yes']:
            print(f"\n{GREEN}üöÄ Initializing new Git repository...{RESET}\n")
            run_command("git init")
        else:
            print(f"\n{YELLOW}üëã Exiting script as no Git repository was found.{RESET}")
            sys.exit(1)

    # Check for changes
    status_output = run_command("git status --porcelain", capture_output=True)
    if not status_output:
        print(f"\n{GREEN}‚úÖ No changes detected. Nothing to commit.{RESET}")
        sys.exit(0)

    # Prompt for commit message (multi-line input)
    commit_message = get_multiline_commit_message()
    if not commit_message:
        print(f"\n{RED}‚ùå Error: Commit message is required.{RESET}")
        sys.exit(1)

    # Add and commit changes
    print(f"{CYAN}----------------------------------------------------{RESET}")
    run_command("git add .")
    run_command(f"git commit -m \"{commit_message}\"")
    print(f"\n{GREEN}üì¶ Changes saved!{RESET}")
    print(f"{CYAN}----------------------------------------------------{RESET}")

    # Ask if user wants to pull
    while True:
        yn = input("\nüîÑ Do you want to pull from origin? (y/n): ").strip().lower()
        if yn in ['y', 'yes']:
            branch = input("\nüåø Enter the branch name to pull from: ").strip()
            if not branch:
                print(f"{RED}‚ùå Error: No branch name provided. Exiting script.{RESET}")
                sys.exit(1)
            print(f"\n{CYAN}----------------------------------------------------{RESET}")
            try:
                run_command(f"git pull origin {branch}")
                print(f"\n{GREEN}‚úÖ Changes pulled from branch {YELLOW}'{branch}'{RESET}{GREEN}!{RESET}")
                print(f"{CYAN}----------------------------------------------------{RESET}")
                break
            except subprocess.CalledProcessError:
                print(f"{RED}‚ùå Error: Failed to pull from branch '{branch}'. Exiting script.{RESET}")
                print(f"{CYAN}----------------------------------------------------{RESET}")
                sys.exit(1)
        elif yn in ['n', 'no']:
            print(f"\n{YELLOW}Pull skipped. Exiting script. üëã{RESET}")
            sys.exit(0)

    # Determine the current branch
    current_branch = run_command("git rev-parse --abbrev-ref HEAD", capture_output=True)

    # Ask if user wants to push
    while True:
        yn = input(f"\nüöÄ Do you want to push changes to the current branch {YELLOW}'{current_branch}'{RESET}? (y/n): ").strip().lower()
        if yn in ['y', 'yes']:
            print(f"\n{CYAN}----------------------------------------------------{RESET}")
            run_command(f"git push origin {current_branch}")
            print(f"\n{GREEN}‚úÖ Changes pushed to remote branch {YELLOW}'{current_branch}'{RESET}{GREEN}!{RESET}")
            print(f"{CYAN}----------------------------------------------------{RESET}")
            break
        elif yn in ['n', 'no']:
            print(f"\n{YELLOW}Push skipped. Exiting script. üëã{RESET}")
            sys.exit(0)

    print(f"\n{BLUE}üëã All done! Have a great day!{RESET}")

if __name__ == "__main__":
    main()
